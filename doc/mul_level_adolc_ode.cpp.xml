<?xml version='1.0'?>
<html xmlns='http://www.w3.org/1999/xhtml'
      xmlns:math='http://www.w3.org/1998/Math/MathML'
>
<head>
<title>Using Adolc with Taylor's Ode Solver: An Example and Test</title>
<meta http-equiv='Content-Type' content='text/html' charset='utf-8'/>
<meta name="description" id="description" content="Using Adolc with Taylor's Ode Solver: An Example and Test"/>
<meta name="keywords" id="keywords" content=" using adolc with taylor's ode solver: an example and test Ode Taylor Adolc purpose solution derivative of method ad base_adolc.hpp memory management configuration requirement "/>
<style type='text/css'>
body { color : black }
body { background-color : white }
A:link { color : blue }
A:visited { color : purple }
A:active { color : purple }
</style>
<script type='text/javascript' language='JavaScript' src='_mul_level_adolc_ode.cpp_xml.js'>
</script>
</head>
<body>
<table><tr>
<td>
<a href="http://www.coin-or.org/CppAD/" target="_top"><img border="0" src="_image.gif"/></a>
</td>
<td><a href="mul_level_ode.cpp.xml" target="_top">Prev</a>
</td><td><a href="ode_taylor.cpp.xml" target="_top">Next</a>
</td><td>
<select onchange='choose_across0(this)'>
<option>Index-&gt;</option>
<option>contents</option>
<option>reference</option>
<option>index</option>
<option>search</option>
<option>external</option>
</select>
</td>
<td>
<select onchange='choose_up0(this)'>
<option>Up-&gt;</option>
<option>CppAD</option>
<option>Example</option>
<option>General</option>
<option>mul_level_adolc_ode.cpp</option>
</select>
</td>
<td>
<select onchange='choose_down3(this)'>
<option>CppAD-&gt;</option>
<option>Install</option>
<option>Introduction</option>
<option>AD</option>
<option>ADFun</option>
<option>preprocessor</option>
<option>multi_thread</option>
<option>library</option>
<option>ipopt_solve</option>
<option>Example</option>
<option>speed</option>
<option>Appendix</option>
</select>
</td>
<td>
<select onchange='choose_down2(this)'>
<option>Example-&gt;</option>
<option>General</option>
<option>ExampleUtility</option>
<option>ListAllExamples</option>
<option>testvector</option>
</select>
</td>
<td>
<select onchange='choose_down1(this)'>
<option>General-&gt;</option>
<option>ad_fun.cpp</option>
<option>ad_in_c.cpp</option>
<option>conj_grad.cpp</option>
<option>cppad_eigen.hpp</option>
<option>hes_minor_det.cpp</option>
<option>hes_lu_det.cpp</option>
<option>interface2c.cpp</option>
<option>jac_minor_det.cpp</option>
<option>jac_lu_det.cpp</option>
<option>mul_level</option>
<option>ode_stiff.cpp</option>
<option>mul_level_ode.cpp</option>
<option>mul_level_adolc_ode.cpp</option>
<option>ode_taylor.cpp</option>
<option>stack_machine.cpp</option>
</select>
</td>
<td>mul_level_adolc_ode.cpp</td>
<td>
<select onchange='choose_current0(this)'>
<option>Headings-&gt;</option>
<option>Purpose</option>
<option>ODE</option>
<option>ODE Solution</option>
<option>Derivative of ODE Solution</option>
<option>Taylor's Method Using AD</option>
<option>base_adolc.hpp</option>
<option>Memory Management</option>
<option>Configuration Requirement</option>
</select>
</td>
</tr></table><br/>



<center><b><big><big>Using Adolc with Taylor's Ode Solver: An Example and Test</big></big></b></center>
<br/>
<b><big><a name="Purpose" id="Purpose">Purpose</a></big></b>
<br/>
This is a realistic example using 
two levels of taping (see <a href="mul_level.xml" target="_top"><span style='white-space: nowrap'>mul_level</span></a>
).
The first level of taping uses Adolc's <code><font color="blue">adouble</font></code> type
to tape the solution of an ordinary differential equation.
This solution is then differentiated with respect to a parameter vector.
The second level of taping uses CppAD's type <code><font color="blue">AD&lt;adouble&gt;</font></code> 
to take derivatives during the solution of the differential equation.
These derivatives are used in the application
of Taylor's method to the solution of the ODE.
The example <a href="mul_level_ode.cpp.xml" target="_top"><span style='white-space: nowrap'>mul_level_ode.cpp</span></a>
 computes the same values using
<code><font color="blue">AD&lt;double&gt;</font></code> and <code><font color="blue">AD&lt; AD&lt;double&gt; &gt;</font></code>.
The example <a href="ode_taylor.cpp.xml" target="_top"><span style='white-space: nowrap'>ode_taylor.cpp</span></a>
 is a simpler applications
of Taylor's method for solving an ODE.

<br/>
<br/>
<b><big><a name="ODE" id="ODE">ODE</a></big></b>
<br/>
For this example the ODE's are defined by the function

<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow>
<mi mathvariant='italic'>h</mi>
<mo stretchy="false">:</mo>
<msup><mrow><mstyle mathvariant='bold'><mi mathvariant='bold'>R</mi>
</mstyle></mrow>
<mi mathvariant='italic'>n</mi>
</msup>
<mo stretchy="false">&#x000D7;</mo>
<msup><mrow><mstyle mathvariant='bold'><mi mathvariant='bold'>R</mi>
</mstyle></mrow>
<mi mathvariant='italic'>n</mi>
</msup>
<mo stretchy="false">&#x02192;</mo>
<msup><mrow><mstyle mathvariant='bold'><mi mathvariant='bold'>R</mi>
</mstyle></mrow>
<mi mathvariant='italic'>n</mi>
</msup>
</mrow></math>

 where

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow>
<mi mathvariant='italic'>h</mi>
<mo stretchy="false">[</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>y</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">]</mo>
<mo stretchy="false">=</mo>
<mrow><mo stretchy="true">(</mo><mrow><mtable rowalign="center" ><mtr><mtd columnalign="center" >
<msub><mi mathvariant='italic'>x</mi>
<mn>0</mn>
</msub>
</mtd></mtr><mtr><mtd columnalign="center" >
<msub><mi mathvariant='italic'>x</mi>
<mn>1</mn>
</msub>
<msub><mi mathvariant='italic'>y</mi>
<mn>0</mn>
</msub>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mtd></mtr><mtr><mtd columnalign="center" >
<mo stretchy="false">&#x022EE;</mo>
</mtd></mtr><mtr><mtd columnalign="center" >
<msub><mi mathvariant='italic'>x</mi>
<mrow><mi mathvariant='italic'>n</mi>
<mn>-1</mn>
</mrow>
</msub>
<msub><mi mathvariant='italic'>y</mi>
<mrow><mi mathvariant='italic'>n</mi>
<mn>-2</mn>
</mrow>
</msub>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mtd></mtr></mtable>
</mrow><mo stretchy="true">)</mo></mrow>
<mo stretchy="false">=</mo>
<mrow><mo stretchy="true">(</mo><mrow><mtable rowalign="center" ><mtr><mtd columnalign="center" >
<msub><mo stretchy="false">&#x02202;</mo>
<mi mathvariant='italic'>t</mi>
</msub>
<msub><mi mathvariant='italic'>y</mi>
<mn>0</mn>
</msub>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mtd></mtr><mtr><mtd columnalign="center" >
<msub><mo stretchy="false">&#x02202;</mo>
<mi mathvariant='italic'>t</mi>
</msub>
<msub><mi mathvariant='italic'>y</mi>
<mn>1</mn>
</msub>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mtd></mtr><mtr><mtd columnalign="center" >
<mo stretchy="false">&#x022EE;</mo>
</mtd></mtr><mtr><mtd columnalign="center" >
<msub><mo stretchy="false">&#x02202;</mo>
<mi mathvariant='italic'>t</mi>
</msub>
<msub><mi mathvariant='italic'>y</mi>
<mrow><mi mathvariant='italic'>n</mi>
<mn>-1</mn>
</mrow>
</msub>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mtd></mtr></mtable>
</mrow><mo stretchy="true">)</mo></mrow>
</mrow></math>

and the initial condition 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow>
<mi mathvariant='italic'>y</mi>
<mo stretchy="false">(</mo>
<mn>0</mn>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">=</mo>
<mn>0</mn>
</mrow></math>

.
The value of 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow>
<mi mathvariant='italic'>x</mi>
</mrow></math>

 is fixed during the solution of the ODE
and the function 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow>
<mi mathvariant='italic'>g</mi>
<mo stretchy="false">:</mo>
<msup><mrow><mstyle mathvariant='bold'><mi mathvariant='bold'>R</mi>
</mstyle></mrow>
<mi mathvariant='italic'>n</mi>
</msup>
<mo stretchy="false">&#x02192;</mo>
<msup><mrow><mstyle mathvariant='bold'><mi mathvariant='bold'>R</mi>
</mstyle></mrow>
<mi mathvariant='italic'>n</mi>
</msup>
</mrow></math>

 is used to
define the ODE where

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow>
<mi mathvariant='italic'>g</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>y</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">=</mo>
<mrow><mo stretchy="true">(</mo><mrow><mtable rowalign="center" ><mtr><mtd columnalign="center" >
<msub><mi mathvariant='italic'>x</mi>
<mn>0</mn>
</msub>
</mtd></mtr><mtr><mtd columnalign="center" >
<msub><mi mathvariant='italic'>x</mi>
<mn>1</mn>
</msub>
<msub><mi mathvariant='italic'>y</mi>
<mn>0</mn>
</msub>
</mtd></mtr><mtr><mtd columnalign="center" >
<mo stretchy="false">&#x022EE;</mo>
</mtd></mtr><mtr><mtd columnalign="center" >
<msub><mi mathvariant='italic'>x</mi>
<mrow><mi mathvariant='italic'>n</mi>
<mn>-1</mn>
</mrow>
</msub>
<msub><mi mathvariant='italic'>y</mi>
<mrow><mi mathvariant='italic'>n</mi>
<mn>-2</mn>
</mrow>
</msub>
</mtd></mtr></mtable>
</mrow><mo stretchy="true">)</mo></mrow>
</mrow></math>

<br/>
<b><big><a name="ODE Solution" id="ODE Solution">ODE Solution</a></big></b>
<br/>
The solution for this example can be calculated by 
starting with the first row and then using the solution
for the first row to solve the second and so on.
Doing this we obtain

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow>
<mi mathvariant='italic'>y</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">=</mo>
<mrow><mo stretchy="true">(</mo><mrow><mtable rowalign="center" ><mtr><mtd columnalign="center" >
<msub><mi mathvariant='italic'>x</mi>
<mn>0</mn>
</msub>
<mi mathvariant='italic'>t</mi>
</mtd></mtr><mtr><mtd columnalign="center" >
<msub><mi mathvariant='italic'>x</mi>
<mn>1</mn>
</msub>
<msub><mi mathvariant='italic'>x</mi>
<mn>0</mn>
</msub>
<msup><mi mathvariant='italic'>t</mi>
<mn>2</mn>
</msup>
<mo stretchy="false">/</mo>
<mn>2</mn>
</mtd></mtr><mtr><mtd columnalign="center" >
<mo stretchy="false">&#x022EE;</mo>
</mtd></mtr><mtr><mtd columnalign="center" >
<msub><mi mathvariant='italic'>x</mi>
<mrow><mi mathvariant='italic'>n</mi>
<mn>-1</mn>
</mrow>
</msub>
<msub><mi mathvariant='italic'>x</mi>
<mrow><mi mathvariant='italic'>n</mi>
<mn>-2</mn>
</mrow>
</msub>
<mo stretchy="false">&#x02026;</mo>
<msub><mi mathvariant='italic'>x</mi>
<mn>0</mn>
</msub>
<msup><mi mathvariant='italic'>t</mi>
<mi mathvariant='italic'>n</mi>
</msup>
<mo stretchy="false">/</mo>
<mi mathvariant='italic'>n</mi>
<mo stretchy="false">!</mo>
</mtd></mtr></mtable>
</mrow><mo stretchy="true">)</mo></mrow>
</mrow></math>

<br/>
<b><big><a name="Derivative of ODE Solution" id="Derivative of ODE Solution">Derivative of ODE Solution</a></big></b>
<br/>
Differentiating the solution above,
with respect to the parameter vector 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow>
<mi mathvariant='italic'>x</mi>
</mrow></math>

,
we notice that

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow>
<msub><mo stretchy="false">&#x02202;</mo>
<mi mathvariant='italic'>x</mi>
</msub>
<mi mathvariant='italic'>y</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">=</mo>
<mrow><mo stretchy="true">(</mo><mrow><mtable rowalign="center" ><mtr><mtd columnalign="center" >
<msub><mi mathvariant='italic'>y</mi>
<mn>0</mn>
</msub>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">/</mo>
<msub><mi mathvariant='italic'>x</mi>
<mn>0</mn>
</msub>
</mtd><mtd columnalign="center" >
<mn>0</mn>
</mtd><mtd columnalign="center" >
<mo stretchy="false">&#x022EF;</mo>
</mtd><mtd columnalign="center" >
<mn>0</mn>
</mtd></mtr><mtr><mtd columnalign="center" >
<msub><mi mathvariant='italic'>y</mi>
<mn>1</mn>
</msub>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">/</mo>
<msub><mi mathvariant='italic'>x</mi>
<mn>0</mn>
</msub>
</mtd><mtd columnalign="center" >
<msub><mi mathvariant='italic'>y</mi>
<mn>1</mn>
</msub>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">/</mo>
<msub><mi mathvariant='italic'>x</mi>
<mn>1</mn>
</msub>
</mtd><mtd columnalign="center" >
<mn>0</mn>
</mtd><mtd columnalign="center" >
<mo stretchy="false">&#x022EE;</mo>
</mtd></mtr><mtr><mtd columnalign="center" >
<mo stretchy="false">&#x022EE;</mo>
</mtd><mtd columnalign="center" >
<mo stretchy="false">&#x022EE;</mo>
</mtd><mtd columnalign="center" >
<mo stretchy="false">&#x022F1;</mo>
</mtd><mtd columnalign="center" >
<mn>0</mn>
</mtd></mtr><mtr><mtd columnalign="center" >
<msub><mi mathvariant='italic'>y</mi>
<mrow><mi mathvariant='italic'>n</mi>
<mn>-1</mn>
</mrow>
</msub>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">/</mo>
<msub><mi mathvariant='italic'>x</mi>
<mn>0</mn>
</msub>
</mtd><mtd columnalign="center" >
<msub><mi mathvariant='italic'>y</mi>
<mrow><mi mathvariant='italic'>n</mi>
<mn>-1</mn>
</mrow>
</msub>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">/</mo>
<msub><mi mathvariant='italic'>x</mi>
<mn>1</mn>
</msub>
</mtd><mtd columnalign="center" >
<mo stretchy="false">&#x022EF;</mo>
</mtd><mtd columnalign="center" >
<msub><mi mathvariant='italic'>y</mi>
<mrow><mi mathvariant='italic'>n</mi>
<mn>-1</mn>
</mrow>
</msub>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">/</mo>
<msub><mi mathvariant='italic'>x</mi>
<mrow><mi mathvariant='italic'>n</mi>
<mn>-1</mn>
</mrow>
</msub>
</mtd></mtr></mtable>
</mrow><mo stretchy="true">)</mo></mrow>
</mrow></math>

<br/>
<b><big><a name="Taylor's Method Using AD" id="Taylor's Method Using AD">Taylor's Method Using AD</a></big></b>
<br/>
An <code><i>m</i></code>-th order Taylor method for 
approximating the solution of an
ordinary differential equations is 

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow>
<mi mathvariant='italic'>y</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">+</mo>
<mi mathvariant='normal'>&#x00394;</mi>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">&#x02248;</mo>
<munderover><mo displaystyle='true' largeop='true'>&#x02211;</mo>
<mrow><mi mathvariant='italic'>k</mi>
<mo stretchy="false">=</mo>
<mn>0</mn>
</mrow>
<mi mathvariant='italic'>p</mi>
</munderover>
<msubsup><mo stretchy="false">&#x02202;</mo>
<mi mathvariant='italic'>t</mi>
<mi mathvariant='italic'>k</mi>
</msubsup>
<mi mathvariant='italic'>y</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mfrac><mrow><mi mathvariant='normal'>&#x00394;</mi>
<msup><mi mathvariant='italic'>t</mi>
<mi mathvariant='italic'>k</mi>
</msup>
</mrow>
<mrow><mi mathvariant='italic'>k</mi>
<mo stretchy="false">!</mo>
</mrow>
</mfrac>
<mo stretchy="false">=</mo>
<msup><mi mathvariant='italic'>y</mi>
<mrow><mo stretchy="false">(</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">+</mo>
<msup><mi mathvariant='italic'>y</mi>
<mrow><mo stretchy="false">(</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mi mathvariant='normal'>&#x00394;</mi>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">+</mo>
<mo stretchy="false">&#x022EF;</mo>
<mo stretchy="false">+</mo>
<msup><mi mathvariant='italic'>y</mi>
<mrow><mo stretchy="false">(</mo>
<mi mathvariant='italic'>p</mi>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mi mathvariant='normal'>&#x00394;</mi>
<msup><mi mathvariant='italic'>t</mi>
<mi mathvariant='italic'>p</mi>
</msup>
</mrow></math>

where the Taylor coefficients 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow>
<msup><mi mathvariant='italic'>y</mi>
<mrow><mo stretchy="false">(</mo>
<mi mathvariant='italic'>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mrow></math>

 are defined by

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow>
<msup><mi mathvariant='italic'>y</mi>
<mrow><mo stretchy="false">(</mo>
<mi mathvariant='italic'>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">=</mo>
<msubsup><mo stretchy="false">&#x02202;</mo>
<mi mathvariant='italic'>t</mi>
<mi mathvariant='italic'>k</mi>
</msubsup>
<mi mathvariant='italic'>y</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">/</mo>
<mi mathvariant='italic'>k</mi>
<mo stretchy="false">!</mo>
</mrow></math>

We define the function 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow>
<mi mathvariant='italic'>z</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mrow></math>

 by the equation

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow>
<mi mathvariant='italic'>z</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">=</mo>
<mi mathvariant='italic'>g</mi>
<mo stretchy="false">[</mo>
<mi mathvariant='italic'>y</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">]</mo>
<mo stretchy="false">=</mo>
<mi mathvariant='italic'>h</mi>
<mo stretchy="false">[</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>y</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">]</mo>
</mrow></math>

It follows that 

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow>
<mtable rowalign="center" ><mtr><mtd columnalign="right" >
<msub><mo stretchy="false">&#x02202;</mo>
<mi mathvariant='italic'>t</mi>
</msub>
<mi mathvariant='italic'>y</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mtd><mtd columnalign="center" >
<mo stretchy="false">=</mo>
</mtd><mtd columnalign="left" >
<mi mathvariant='italic'>z</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mtd></mtr><mtr><mtd columnalign="right" >
<msubsup><mo stretchy="false">&#x02202;</mo>
<mi mathvariant='italic'>t</mi>
<mrow><mi mathvariant='italic'>k</mi>
<mo stretchy="false">+</mo>
<mn>1</mn>
</mrow>
</msubsup>
<mi mathvariant='italic'>y</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mtd><mtd columnalign="center" >
<mo stretchy="false">=</mo>
</mtd><mtd columnalign="left" >
<msubsup><mo stretchy="false">&#x02202;</mo>
<mi mathvariant='italic'>t</mi>
<mi mathvariant='italic'>k</mi>
</msubsup>
<mi mathvariant='italic'>z</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mtd></mtr><mtr><mtd columnalign="right" >
<msup><mi mathvariant='italic'>y</mi>
<mrow><mo stretchy="false">(</mo>
<mi mathvariant='italic'>k</mi>
<mo stretchy="false">+</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mtd><mtd columnalign="center" >
<mo stretchy="false">=</mo>
</mtd><mtd columnalign="left" >
<msup><mi mathvariant='italic'>z</mi>
<mrow><mo stretchy="false">(</mo>
<mi mathvariant='italic'>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">/</mo>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>k</mi>
<mo stretchy="false">+</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mtd></mtr></mtable>
</mrow></math>

where 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow>
<msup><mi mathvariant='italic'>z</mi>
<mrow><mo stretchy="false">(</mo>
<mi mathvariant='italic'>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mrow></math>

 is the 
<code><i>k</i></code>-th order Taylor coefficient
for 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow>
<mi mathvariant='italic'>z</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mrow></math>

.
In the example below, the Taylor coefficients

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow>
<msup><mi mathvariant='italic'>y</mi>
<mrow><mo stretchy="false">(</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">,</mo>
<mo stretchy="false">&#x02026;</mo>
<mo stretchy="false">,</mo>
<msup><mi mathvariant='italic'>y</mi>
<mrow><mo stretchy="false">(</mo>
<mi mathvariant='italic'>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mrow></math>

are used to calculate the Taylor coefficient 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow>
<msup><mi mathvariant='italic'>z</mi>
<mrow><mo stretchy="false">(</mo>
<mi mathvariant='italic'>k</mi>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mrow></math>


which in turn gives the value for 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow>
<msup><mi mathvariant='italic'>y</mi>
<mrow><mo stretchy="false">(</mo>
<mi mathvariant='italic'>k</mi>
<mo stretchy="false">+</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<mi mathvariant='italic'>y</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>t</mi>
<mo stretchy="false">,</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mrow></math>

.

<br/>
<br/>
<b><big><a name="base_adolc.hpp" id="base_adolc.hpp">base_adolc.hpp</a></big></b>
<br/>
The file <a href="base_adolc.hpp.xml" target="_top"><span style='white-space: nowrap'>base_adolc.hpp</span></a>
 is implements the
<a href="base_require.xml" target="_top"><span style='white-space: nowrap'>Base&#xA0;type&#xA0;requirements</span></a>
 where 
<code><i><font color="black"><span style='white-space: nowrap'>Base</span></font></i></code>

is <code><font color="blue">adolc</font></code>.

<br/>
<br/>
<b><big><a name="Memory Management" id="Memory Management">Memory Management</a></big></b>
<br/>
Adolc uses raw memory arrays that depend on the number of 
dependent and independent variables.
The memory management utility <a href="omp_alloc.xml" target="_top"><span style='white-space: nowrap'>omp_alloc</span></a>
 
is used to manage this memory allocation.

<br/>
<br/>
<b><big><a name="Configuration Requirement" id="Configuration Requirement">Configuration Requirement</a></big></b>
<br/>
This example will be compiled and tested provided that
the value <a href="ipopt_prefix.xml" target="_top"><span style='white-space: nowrap'>ipopt_prefix</span></a>
 is specified on the 
<a href="cmake.xml" target="_top"><span style='white-space: nowrap'>cmake</span></a>
 command line.

<code><font color="blue">
<pre style='display:inline'> 
# include &lt;adolc/adouble.h&gt;
# include &lt;adolc/taping.h&gt;
# include &lt;adolc/drivers/drivers.h&gt;

// definitions not in Adolc distribution and required to use CppAD::<a href="ad.xml" target="_top">AD</a>&lt;adouble&gt;
# include &lt;cppad/example/base_adolc.hpp&gt;

# include &lt;cppad/cppad.hpp&gt;
// ==========================================================================
namespace { // BEGIN empty namespace
// define types for each level
typedef adouble            ADdouble;
typedef CppAD::<a href="ad.xml" target="_top">AD</a>&lt;adouble&gt; ADDdouble;

// -------------------------------------------------------------------------
// class definition for C++ function object that defines ODE
class Ode {
private:
	// copy of a that is set by constructor and used by g(y)
	<a href="testvector.xml" target="_top">CPPAD_TESTVECTOR</a>( ADdouble ) x_; 
public:
	// constructor
	Ode( <a href="testvector.xml" target="_top">CPPAD_TESTVECTOR</a>( ADdouble ) x) : x_(x)
	{ }
	// the function g(y) is evaluated with two levels of taping
	<a href="testvector.xml" target="_top">CPPAD_TESTVECTOR</a>( ADDdouble ) operator()
	( const <a href="testvector.xml" target="_top">CPPAD_TESTVECTOR</a>( ADDdouble ) &amp;y) const
	{	size_t n = y.size();
		<a href="testvector.xml" target="_top">CPPAD_TESTVECTOR</a>( ADDdouble ) g(n);
		size_t i;
		g[0] = x_[0];
		for(i = 1; i &lt; n; i++)
			g[i] = x_[i] * y[i-1];

		return g;
	}
};

// -------------------------------------------------------------------------
// Routine that uses Taylor's method to solve ordinary differential equaitons
// and allows for algorithmic differentiation of the solution. 
<a href="testvector.xml" target="_top">CPPAD_TESTVECTOR</a>( ADdouble ) taylor_ode_adolc(
	Ode                     G       ,  // function that defines the ODE
	size_t                  order   ,  // order of Taylor's method used
	size_t                  nstep   ,  // number of steps to take
	ADdouble                &amp;dt     ,  // Delta t for each step
	<a href="testvector.xml" target="_top">CPPAD_TESTVECTOR</a>( ADdouble ) &amp;y_ini  )  // y(t) at the initial time
{
	// some temporary indices
	size_t i, k, ell;

	// number of variables in the ODE
	size_t n = y_ini.size();

	// copies of x and g(y) with two levels of taping
	<a href="testvector.xml" target="_top">CPPAD_TESTVECTOR</a>( ADDdouble )   Y(n), Z(n);

	// y, y^{(k)} , z^{(k)}, and y^{(k+1)}
	<a href="testvector.xml" target="_top">CPPAD_TESTVECTOR</a>( ADdouble )  y(n), y_k(n), z_k(n), y_kp(n);
	
	// initialize x
	for(i = 0; i &lt; n; i++)
		y[i] = y_ini[i];

	// loop with respect to each step of Taylors method
	for(ell = 0; ell &lt; nstep; ell++)
	{	// prepare to compute derivatives of in ADdouble
		for(i = 0; i &lt; n; i++)
			Y[i] = y[i];
		CppAD::<a href="independent.xml" target="_top">Independent</a>(Y);

		// evaluate ODE in ADDdouble
		Z = G(Y);

		// define differentiable version of g: X -&gt; Y
		// that computes its derivatives in ADdouble
		CppAD::<a href="funconstruct.xml" target="_top">ADFun</a>&lt;ADdouble&gt; g(Y, Z);

		// Use Taylor's method to take a step
		y_k            = y;     // initialize y^{(k)}
		ADdouble dt_kp = dt;    // initialize dt^(k+1)
		for(k = 0; k &lt;= order; k++)
		{	// evaluate k-th order Taylor coefficient of y
			z_k = g.<a href="forward.xml" target="_top">Forward</a>(k, y_k);
 
			for(i = 0; i &lt; n; i++)
			{	// convert to (k+1)-Taylor coefficient for x
				y_kp[i] = z_k[i] / ADdouble(k + 1);

				// add term for to this Taylor coefficient
				// to solution for y(t, x)
				y[i]    += y_kp[i] * dt_kp;
			}
			// next power of t
			dt_kp *= dt;
			// next Taylor coefficient
			y_k   = y_kp;
		}
	}
	return y;
}
} // END empty namespace
// ==========================================================================
// Routine that tests algorithmic differentiation of solutions computed
// by the routine taylor_ode.
bool mul_level_adolc_ode(void)
{	// initialize the return value as true	
	bool ok = true;

	// number of components in differential equation
	size_t n = 4;

	// some temporary indices
	size_t i, j;

	// set up for omp_alloc memory allocator
	using CppAD::omp_alloc; // the allocator
	size_t capacity;        // capacity of an allocation

	// the vector x with lenght n (or greater) in double 
	double* x = omp_alloc::create_array&lt;double&gt;(n, capacity);
	// the vector x with lenght n in ADouble
	<a href="testvector.xml" target="_top">CPPAD_TESTVECTOR</a>(ADdouble) X(n);
	for(i = 0; i &lt; n; i++)
		X[i] = x[i] = double(i + 1);

	// declare the parameters as the independent variable
	int tag = 0;                     // Adolc setup
	int keep = 1;
	trace_on(tag, keep);
	for(i = 0; i &lt; n; i++)
		X[i] &lt;&lt;= double(i + 1);  // X is independent for adouble type

	// arguments to taylor_ode_adolc 
	Ode G(X);                // function that defines the ODE
	size_t   order = n;      // order of Taylor's method used
	size_t   nstep = 2;      // number of steps to take
	ADdouble DT    = 1.;     // Delta t for each step
	// value of y(t, x) at the initial time
	<a href="testvector.xml" target="_top">CPPAD_TESTVECTOR</a>( ADdouble ) Y_INI(n);
	for(i = 0; i &lt; n; i++)
		Y_INI[i] = 0.;

	// integrate the differential equation
	<a href="testvector.xml" target="_top">CPPAD_TESTVECTOR</a>( ADdouble ) Y_FINAL(n);
 	Y_FINAL = taylor_ode_adolc(G, order, nstep, DT, Y_INI);

	// declare the differentiable fucntion f : A -&gt; Y_FINAL
	// (corresponding to the tape of adouble operations)
	double* y_final = omp_alloc::create_array&lt;double&gt;(n, capacity);
	for(i = 0; i &lt; n; i++)
		Y_FINAL[i] &gt;&gt;= y_final[i];
	trace_off();

	// check function values
	double check = 1.;
	double t     = nstep * DT.value();
	for(i = 0; i &lt; n; i++)
	{	check *= x[i] * t / double(i + 1);
		ok &amp;= CppAD::<a href="nearequal.xml" target="_top">NearEqual</a>(y_final[i], check, 1e-10, 1e-10);
	}

	// memory where Jacobian will be returned
	double* jac_ = omp_alloc::create_array&lt;double&gt;(n * n, capacity); 
	double** jac = omp_alloc::create_array&lt;double*&gt;(n, capacity);
	for(i = 0; i &lt; n; i++)
		jac[i] = jac_ + i * n;

	// evaluate Jacobian of h at a
	size_t m = n;              // # dependent variables
	jacobian(tag, int(m), int(n), x, jac); 
	
	// check Jacobian 
	for(i = 0; i &lt; n; i++)
	{	for(j = 0; j &lt; n; j++)
		{	if( i &lt; j )
				check = 0.;
			else	check = y_final[i] / x[j];
			ok &amp;= CppAD::<a href="nearequal.xml" target="_top">NearEqual</a>(jac[i][j], check, 1e-10, 1e-10);
		}
	}

	// make memroy avaiable for other use by this thread
	omp_alloc::delete_array(x);
	omp_alloc::delete_array(y_final);
	omp_alloc::delete_array(jac_);
	omp_alloc::delete_array(jac);
	return ok;
}

</pre>

</font></code>


<hr/>Input File: example/mul_level_adolc_ode.cpp

</body>
</html>
