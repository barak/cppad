<?xml version='1.0'?>
<html xmlns='http://www.w3.org/1999/xhtml'
      xmlns:math='http://www.w3.org/1998/Math/MathML'
>
<head>
<title>Computing Dependency: Example and Test</title>
<meta http-equiv='Content-Type' content='text/html' charset='utf-8'/>
<meta name="description" id="description" content="Computing Dependency: Example and Test"/>
<meta name="keywords" id="keywords" content=" computing dependency: example and test discussion dependency pattern "/>
<style type='text/css'>
body { color : black }
body { background-color : white }
A:link { color : blue }
A:visited { color : purple }
A:active { color : purple }
</style>
<script type='text/javascript' language='JavaScript' src='_dependency.cpp_xml.js'>
</script>
</head>
<body>
<table><tr>
<td>
<a href="http://www.coin-or.org/CppAD/" target="_top"><img border="0" src="_image.gif"/></a>
</td>
<td><a href="rev_sparse_jac.cpp.xml" target="_top">Prev</a>
</td><td><a href="revsparsehes.xml" target="_top">Next</a>
</td><td>
<select onchange='choose_across0(this)'>
<option>Index-&gt;</option>
<option>contents</option>
<option>reference</option>
<option>index</option>
<option>search</option>
<option>external</option>
</select>
</td>
<td>
<select onchange='choose_up0(this)'>
<option>Up-&gt;</option>
<option>CppAD</option>
<option>ADFun</option>
<option>FunEval</option>
<option>Sparse</option>
<option>dependency.cpp</option>
</select>
</td>
<td>
<select onchange='choose_down3(this)'>
<option>ADFun-&gt;</option>
<option>Independent</option>
<option>FunConstruct</option>
<option>Dependent</option>
<option>abort_recording</option>
<option>seq_property</option>
<option>FunEval</option>
<option>Drivers</option>
<option>FunCheck</option>
<option>optimize</option>
<option>check_for_nan</option>
</select>
</td>
<td>
<select onchange='choose_down2(this)'>
<option>FunEval-&gt;</option>
<option>Forward</option>
<option>Reverse</option>
<option>Sparse</option>
</select>
</td>
<td>
<select onchange='choose_down1(this)'>
<option>Sparse-&gt;</option>
<option>ForSparseJac</option>
<option>RevSparseJac</option>
<option>dependency.cpp</option>
<option>RevSparseHes</option>
<option>bool_sparsity.cpp</option>
</select>
</td>
<td>dependency.cpp</td>
<td>
<select onchange='choose_current0(this)'>
<option>Headings-&gt;</option>
<option>Discussion</option>
<option>Dependency Pattern</option>
</select>
</td>
</tr></table><br/>



<center><b><big><big>Computing Dependency: Example and Test</big></big></b></center>
<br/>
<b><big><a name="Discussion" id="Discussion">Discussion</a></big></b>
<br/>
The partial of an dependent variable with respect to an independent variable
might always be zero even though the dependent variable depends on the
value of the dependent variable. Consider the following case

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow>
<mi mathvariant='italic'>f</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">=</mo>
<mrow><mstyle mathvariant='normal'><mi mathvariant='normal'>sign</mi>
</mstyle></mrow>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
<mo stretchy="false">=</mo>
<mrow><mo stretchy="true">{</mo><mrow><mtable rowalign="center" ><mtr><mtd columnalign="right" >
<mo stretchy="false">+</mo>
<mn>1</mn>
</mtd><mtd columnalign="left" >
<mrow><mstyle mathvariant='normal'><mi mathvariant='normal'>if</mi>
</mstyle></mrow>
<mspace width='.3em'/>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">&gt;</mo>
<mn>0</mn>
</mtd></mtr><mtr><mtd columnalign="right" >
<mn>0</mn>
</mtd><mtd columnalign="left" >
<mrow><mstyle mathvariant='normal'><mi mathvariant='normal'>if</mi>
</mstyle></mrow>
<mspace width='.3em'/>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">=</mo>
<mn>0</mn>
</mtd></mtr><mtr><mtd columnalign="right" >
<mn>-1</mn>
</mtd><mtd columnalign="left" >
<mrow><mstyle mathvariant='normal'><mi mathvariant='normal'>if</mi>
</mstyle></mrow>
<mspace width='.3em'/>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">&lt;</mo>
<mn>0</mn>
</mtd></mtr></mtable>
</mrow><mo stretchy="true"> </mo></mrow>
</mrow></math>

In this case the value of 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow>
<mi mathvariant='italic'>f</mi>
<mo stretchy="false">(</mo>
<mi mathvariant='italic'>x</mi>
<mo stretchy="false">)</mo>
</mrow></math>

 depends on the value of 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow>
<mi mathvariant='italic'>x</mi>
</mrow></math>


but CppAD always returns zero for the derivative of the <a href="sign.xml" target="_top"><span style='white-space: nowrap'>sign</span></a>
 function.

<br/>
<br/>
<b><big><a name="Dependency Pattern" id="Dependency Pattern">Dependency Pattern</a></big></b>
<br/>
If the <code><i>i</i></code>-th dependent variables depends on the
value of the <code><i>j</i></code>-th independent variable,
the corresponding entry in the dependency pattern is non-zero (true).
Otherwise it is zero (false).
CppAD uses <a href="glossary.xml#Sparsity Pattern" target="_top"><span style='white-space: nowrap'>sparsity&#xA0;patterns</span></a>

to represent dependency matrices.
The 
<code><i><font color="black"><span style='white-space: nowrap'>dependency</span></font></i></code>
 argument to
<a href="forsparsejac.xml#dependency" target="_top"><span style='white-space: nowrap'>ForSparseJac</span></a>
 and
<a href="revsparsejac.xml#dependency" target="_top"><span style='white-space: nowrap'>RevSparseJac</span></a>
 is a flag that signals
that the dependency pattern (instead of the sparsity pattern) is computed.

<code><font color="blue">
<pre style='display:inline'> 
# include &lt;cppad/cppad.hpp&gt;
namespace {
	double heavyside(const double&amp; x)
	{	if( x &lt;= 0.0 )
			return 0.0;
		return 1.0;
	}
	CPPAD_DISCRETE_FUNCTION(double, heavyside)
}

bool dependency(void)
{	bool ok = true;
	using CppAD::AD;
	using CppAD::NearEqual;

	// VecAD object for use later
	CppAD::VecAD&lt;double&gt; vec_ad(2);
	vec_ad[0] = 0.0;
	vec_ad[1] = 1.0;

	// domain space vector
	size_t n  = 5;
	<a href="testvector.xml" target="_top">CPPAD_TESTVECTOR</a>(AD&lt;double&gt;) ax(n);
	for(size_t j = 0; j &lt; n; j++)
		ax[j] = <a href="ad.xml" target="_top">AD</a>&lt;double&gt;(j + 1);

	// declare independent variables and start tape recording
	CppAD::<a href="independent.xml" target="_top">Independent</a>(ax);

	// some AD constants
	<a href="ad.xml" target="_top">AD</a>&lt;double&gt; azero(0.0), aone(1.0);

	// range space vector
	size_t m  = n;
	size_t m1 = n - 1;
	<a href="testvector.xml" target="_top">CPPAD_TESTVECTOR</a>(AD&lt;double&gt;) ay(m);
	ay[m1-0] = sign( ax[0] );
	ay[m1-1] = CondExpLe( ax[1], azero, azero, aone);
	ay[m1-2] = CondExpLe( azero, ax[2], azero, aone);
	ay[m1-3] = heavyside( ax[3] );
	ay[m1-4] = vec_ad[ ax[4] - <a href="ad.xml" target="_top">AD</a>&lt;double&gt;(4.0) ];

	// create f: x -&gt; y and stop tape recording
	CppAD::<a href="funconstruct.xml" target="_top">ADFun</a>&lt;double&gt; f(ax, ay);

	// -----------------------------------------------------------
	// ForSparseJac and bool dependency
	bool transpose  = false;
	bool dependency;
	// could replace CppAD::vectorBooll by CPPAD_TEST_VECTOR&lt;bool&gt;
	CppAD::vectorBool eye_bool(n * n), depend_bool(m * n);
	for(size_t i = 0; i &lt; n; i++)
	{	for(size_t j = 0; j &lt; n; j++)
			eye_bool[i * n + j] = (i == j);
	}
	dependency = true;
	depend_bool = f.ForSparseJac(n, eye_bool, transpose, dependency);
	for(size_t i = 0; i &lt; m; i++)
	{	for(size_t j = 0; j &lt; n; j++)
			ok &amp;= depend_bool[i * n + j] == (i == (m1-j));
	}
	dependency = false;
	depend_bool = f.ForSparseJac(n, eye_bool, transpose, dependency);
	for(size_t i = 0; i &lt; m; i++)
	{	for(size_t j = 0; j &lt; n; j++)
			ok &amp;= depend_bool[i * n + j] == false;
	}

	// -----------------------------------------------------------
	// RevSparseJac and set dependency
	CppAD::vector&lt;    std::set&lt;size_t&gt; &gt; eye_set(m), depend_set(m);
	for(size_t i = 0; i &lt; m; i++)
	{	ok &amp;= eye_set[i].empty();
		eye_set[i].insert(i);
	}
	dependency = true;
	depend_set = f.RevSparseJac(n, eye_set, transpose, dependency);
	for(size_t i = 0; i &lt; m; i++)
	{	std::set&lt;size_t&gt; check;
		check.insert(m1 - i);
		ok &amp;= depend_set[i] == check;
	}
	dependency = false;
	depend_set = f.RevSparseJac(n, eye_set, transpose, dependency);
	for(size_t i = 0; i &lt; m; i++)
		ok &amp;= depend_set[i].empty();
	return ok;
}

</pre>

</font></code>


<hr/>Input File: example/dependency.cpp

</body>
</html>
